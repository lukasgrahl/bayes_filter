# Hello. I'm coding the ARIMA filter here for simplicity of results. 
# NEed to test iin jupyter notebook 

# %run init_notebookspace.py

# import pandas as pd
# from pandas_datareader import fred
# import yfinance as yf
#
# import matplotlib.pyplot as plt
#
# from statsmodels.tsa.stattools import adfuller
# from numpy import log
# import pandas as pd
#
# from statsmodels.tsa.arima.model import ARIMA
#
# Code source imported data.csv here
# Checking for statoinarity via ADF test below

mydata = pd.read_csv()

res = adfuller( mydata.value.dropna())  
print('Augmented Dickey-Fuller Statistic: %f' % res[0])  
print('p-value: %f' % res[1])   

# determining the ADF for the 'd' value of ARIMA 

# Next looking at autocorrelation 

import numpy as np, pandas as pd  
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf  
import matplotlib.pyplot as plt  
  
plt.rcParams.update({'figure.figsize' : (9,7), 'figure.dpi' : 120})  
  
# Importing data  
df = pd.read_csv('mydataset.csv', names = ['value'], header = 0)  
  
# The Genuine Series  
fig, axes = plt.subplots(3, 2, sharex = True)  
axes[0, 0].plot(df.value); axes[0, 0].set_title('The Genuine Series')  
plot_acf(df.value, ax = axes[0, 1])  
  
# Order of Differencing: First  
axes[1, 0].plot(df.value.diff()); axes[1, 0].set_title('Order of Differencing: First')  
plot_acf(df.value.diff().dropna(), ax = axes[1, 1])  
  
# Order of Differencing: Second  
axes[2, 0].plot(df.value.diff().diff()); axes[2, 0].set_title('Order of Differencing: Second')  
plot_acf(df.value.diff().diff().dropna(), ax = axes[2, 1])  
  
plt.show()  

# Determine the differencing above. Weak/ strong stationarity? 
# Next, looking at how to make the data stationary via 3 tests. 

from pmdarima.arima.utils import ndiffs  
import pandas as pd  
  
df = pd.read_csv('mydataset.csv', names = ['value'], header = 0)  
X = df.value  
  
# Augmented Dickey Fuller Test  
adftest = ndiffs(X, test = 'adf')  
  
# KPSS Test  
kpsstest = ndiffs(X, test = 'kpss')  
  
# PP Test  
pptest = ndiffs(X, test = 'pp')  
  
print("ADF Test =", adftest)  
print("KPSS Test =", kpsstest)  
print("PP Test =", pptest) 

#Next finding the 'p' term for AR via a partial auocorrelatoin graph

import numpy as np, pandas as pd  
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf  
import matplotlib.pyplot as plt  
  
plt.rcParams.update({'figure.figsize':(9,3), 'figure.dpi':120})  
  
# importing data  
df = pd.read_csv('mydataset.csv', names = ['value'], header = 0)  
  
fig, axes = plt.subplots(1, 2, sharex = True)  
axes[0].plot(df.value.diff()); axes[0].set_title('Order of Differencing: First')  
axes[1].set(ylim = (0,5))  
plot_pacf(df.value.diff().dropna(), ax = axes[1])  
  
plt.show()  

# Look a the blue region to determine if it is useful or not

#Next, finding the 'q' MA 

import numpy as np, pandas as pd  
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf  
import matplotlib.pyplot as plt  
  
plt.rcParams.update({'figure.figsize' : (9,3), 'figure.dpi' : 120})  
  
# importing data  
mydata = pd.read_csv('mydataset.csv', names = ['value'], header = 0)  
  
fig, axes = plt.subplots(1, 2, sharex = True)  
axes[0].plot(mydata.value.diff()); axes[0].set_title('Order of Differencing: First')  
axes[1].set(ylim = (0, 1.2))  
plot_acf(mydata.value.diff().dropna(), ax = axes[1])  
  
plt.show()  

# Looking at the autocorrelation graph, we can determine the number needed for q 

# Now building the ARIMA model 

import numpy as np, pandas as pd  
from statsmodels.tsa.arima_model import ARIMA  
  
# importing data  
mydata = pd.read_csv('mydataset.csv', names = ['value'], header = 0)  
  
# Creating ARIMA model  
# change the () to whatever numbers we get from the results for p,d,q above 
mymodel = ARIMA(mydata.value, order = (1, 1, 2))  
modelfit = mymodel.fit(disp = 0)  
print(modelfit.summary())  

# These are the results. We can alter the output by changing the AIC/ BIC if we have a close call. 

# Now we plot the residuals to ensure that there is no constant mean or varaince to worry about 

import numpy as np, pandas as pd  
from statsmodels.tsa.arima_model import ARIMA  
import matplotlib.pyplot as plt  
  
plt.rcParams.update({'figure.figsize' : (9,3), 'figure.dpi' : 120})  
  
# importing data  
mydata = pd.read_csv('mydataset.csv', names = ['value'], header = 0)  
  
# Creating ARIMA model  
mymodel = ARIMA(mydata.value, order = (1, 1, 1))  
modelfit = mymodel.fit(disp = 0)  
  
# Plotting Residual Errors  
myresiduals = pd.DataFrame(modelfit.resid)  
fig, ax = plt.subplots(1,2)  
myresiduals.plot(title = "Residuals", ax = ax[0])  
myresiduals.plot(kind = 'kde', title = 'Density', ax = ax[1])  
plt.show()  

# finally, graphin gour predicted versus actual values for trend analysis 

import numpy as np, pandas as pd  
from statsmodels.tsa.arima_model import ARIMA  
import matplotlib.pyplot as plt  
  
plt.rcParams.update({'figure.figsize' : (9,3), 'figure.dpi' : 120})  
  
# importing data  
mydata = pd.read_csv('mydataset.csv', names = ['value'], header = 0)  
  
# Creating ARIMA model  
mymodel = ARIMA(mydata.value, order = (1, 1, 1))  
modelfit = mymodel.fit(disp = 0)  
  
# Actual vs Fitted  
modelfit.plot_predict(dynamic = False)  
plt.show()  

